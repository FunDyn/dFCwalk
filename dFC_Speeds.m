function [typSpeed, Speeds] = dFC_Speeds(dFCstream, vstep)

% FUNCTION [typSpeed, Speeds] = dFC_Speeds(dFCstream, vstep)
% takes dFCstream ('2D' or '3D') generated by TS2dFCstream function and vstep
% as input, telling the distance in terms of stream steps over which to
% compute a speed of variation (via correlation distance)
% 
% If the dFCstream has already been computed with a lag=W, then the vstep
% for speed computation should be one (vstep=1, default); 
% If dFCsteam is oversampled (e.g. W=10, lag=1), then speed computation 
% can be corrected by vstep=W (e.g. vstep=10) to evaluate distance
% between FC slices from non over-lapping windows.
%
% outputs: typSpeed --> (default) median of computed distribution of speeds.
%          Speeds   --> the entire time-series of speeds can be printed which
%                       is needed for analyses of sequential correlations or
%                       for window-size pooled analyses
%
% Examples: [typSpeed, Speeds] = dFC_Speeds(TS2dFCstream(TS, W))
%           [typSpeed, Speeds] = dFC_Speeds(TS2dFCstream(TS, W, 1), W)



if (nargin < 2)
    vstep = 1;
end

if (ndims(dFCstream) == 3)   
    nslices = size(dFCstream, 3);
    FCstr = reshapedFCstream(dFCstream);
end

if (ndims(dFCstream) == 2)   
    nslices = size(dFCstream, 2);
    FCstr = dFCstream;
end

if (ndims(dFCstream) < 2)   
    disp('Provide a valid size dFCstream (3D or stream objects)!')
    return
end

if (ndims(dFCstream) > 3)   
    disp('Provide a valid size dFCstream (3D or stream objects)!')
    return
end

HowManySpeeds = 0;
for s = 1:(nslices-1)
    if ((s + vstep) <= nslices)
        HowManySpeeds = HowManySpeeds + 1;
    end
end
Speeds = zeros(HowManySpeeds,1);

h = 0;
for s = 1:(nslices - 1)
    if ((s + vstep) <= nslices)
        h = h+1;
        FC1 = FCstr(:,s);
        FC2 = FCstr(:,s+vstep);
        Speeds(h) = 1 - corr(FC1,FC2);
    end
end

typSpeed = median(Speeds);

    


